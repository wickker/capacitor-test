import {
  __export
} from "./chunk-E3EO7R6B.js";

// node_modules/@roxi/routify/runtime/plugins/tree.js
var tree_exports = {};
__export(tree_exports, {
  addMetaChildren: () => addMetaChildren,
  assignIndex: () => assignIndex,
  assignLayout: () => assignLayout,
  assignRelations: () => assignRelations,
  createFlatList: () => createFlatList,
  setIsIndexable: () => setIsIndexable,
  setParamKeys: () => setParamKeys,
  setPrototype: () => setPrototype,
  setRank: () => setRank,
  setRegex: () => setRegex,
  setShortPath: () => setShortPath
});

// node_modules/@roxi/routify/runtime/middleware.js
function createNodeMiddleware(fn) {
  const inner = async function execute(payload) {
    return await nodeMiddleware(fn, {
      file: payload.tree,
      state: { treePayload: payload },
      scope: {}
    });
  };
  inner.sync = function executeSync(payload) {
    return nodeMiddlewareSync(fn, {
      file: payload.tree,
      state: { treePayload: payload },
      scope: {}
    });
  };
  return inner;
}
async function nodeMiddleware(fn, payload) {
  const _file = await fn(payload);
  if (_file === false)
    return false;
  const file = _file || payload.file;
  if (file.children) {
    const children = await Promise.all(file.children.map(async (_file2) => nodeMiddleware(fn, {
      state: payload.state,
      scope: clone(payload.scope || {}),
      parent: payload.file,
      file: await _file2
    })));
    file.children = children.filter(Boolean);
  }
  return file;
}
function nodeMiddlewareSync(fn, payload) {
  const _file = fn(payload);
  if (_file === false)
    return false;
  const file = _file || payload.file;
  if (file.children) {
    const children = file.children.map((_file2) => nodeMiddlewareSync(fn, {
      state: payload.state,
      scope: clone(payload.scope || {}),
      parent: payload.file,
      file: _file2
    }));
    file.children = children.filter(Boolean);
  }
  return file;
}
function clone(obj) {
  return JSON.parse(JSON.stringify(obj));
}

// node_modules/@roxi/routify/runtime.config.js
var runtime_config_default = {
  queryHandler: {
    parse: (search) => fromEntries(new URLSearchParams(search)),
    stringify: (params) => "?" + new URLSearchParams(params).toString()
  },
  urlTransform: {
    apply: (x) => x,
    remove: (x) => x
  },
  useHash: false
};
function fromEntries(iterable) {
  return [...iterable].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
}

// node_modules/@roxi/routify/runtime/utils/index.js
var MATCH_PARAM = RegExp(/\:([^/()]+)/g);
function handleScroll(element, scrollToTop) {
  if (navigator.userAgent.includes("jsdom"))
    return false;
  if (scrollToTop)
    scrollAncestorsToTop(element);
  handleHash();
}
function handleHash() {
  if (navigator.userAgent.includes("jsdom"))
    return false;
  const { hash } = window.location;
  if (hash) {
    const el = document.getElementById(hash.substring(1));
    if (el)
      el.scrollIntoView();
  }
}
function scrollAncestorsToTop(element) {
  if (element && element.scrollTo && element.dataset.routify !== "scroll-lock" && element.dataset["routify-scroll"] !== "lock") {
    element.style["scroll-behavior"] = "auto";
    element.scrollTo({ top: 0, behavior: "auto" });
    element.style["scroll-behavior"] = "";
    scrollAncestorsToTop(element.parentElement);
  }
}
var pathToRegex = (str, recursive) => {
  const suffix = recursive ? "" : "/?$";
  str = str.replace(/\/_fallback?$/, "(/|$)");
  str = str.replace(/\/index$/, "(/index)?");
  str = str.replace(MATCH_PARAM, "([^/]+)") + suffix;
  str = `^${str}`;
  return str;
};
var pathToParamKeys = (string) => {
  const paramsKeys = [];
  let matches;
  while (matches = MATCH_PARAM.exec(string))
    paramsKeys.push(matches[1]);
  return paramsKeys;
};
var pathToRank = ({ path }) => {
  return path.split("/").filter(Boolean).map((str) => str === "_fallback" ? "A" : str.startsWith(":") ? "B" : "C").join("");
};
function suppressComponentWarnings(ctx, tick) {
  suppressComponentWarnings._console = suppressComponentWarnings._console || { log: console.log, warn: console.warn };
  const { _console } = suppressComponentWarnings;
  const name = ctx.componentFile.name.replace(/Proxy<_?(.+)>/, "$1").replace(/^Index$/, ctx.component.shortPath.split("/").pop()).replace(/^./, (s) => s.toUpperCase()).replace(/\:(.+)/, "U5B$1u5D");
  const ignores = [
    `<${name}> received an unexpected slot "default".`,
    `<${name}> was created with unknown prop 'scoped'`,
    `<${name}> was created with unknown prop 'scopedSync'`
  ];
  for (const log of ["log", "warn"]) {
    console[log] = (...args) => {
      if (!ignores.includes(args[0]))
        _console[log](...args);
    };
    tick().then(() => {
      console[log] = _console[log];
    });
  }
}
function currentLocation() {
  let dirtyFullpath = window.location.pathname + window.location.search + window.location.hash;
  const { url, options } = resolvePrefetch(dirtyFullpath);
  const parsedUrl = parseUrl(url);
  return { ...parsedUrl, options };
}
function resolvePrefetch(dirtyFullpath) {
  const [url, _options] = dirtyFullpath.split("__[[routify_url_options]]__");
  const options = JSON.parse(decodeURIComponent(_options || "") || "{}");
  window.routify = window.routify || {};
  window.routify.prefetched = options.prefetch;
  return { url, options };
}
function parseUrl(url) {
  if (runtime_config_default.useHash)
    url = url.replace(/.*#(.+)/, "$1");
  const origin = url.startsWith("/") ? window.location.origin : void 0;
  const _url = new URL(url, origin);
  const fullpath = _url.pathname + _url.search + _url.hash;
  return { url: _url, fullpath };
}
function resolveUrl(path, params, inheritedParams) {
  const hash = runtime_config_default.useHash ? "#" : "";
  let url;
  url = populateUrl(path, params, inheritedParams);
  url = runtime_config_default.urlTransform.apply(url);
  url = hash + url;
  return url;
}
function populateUrl(path, params, inheritedParams) {
  const allParams = Object.assign({}, inheritedParams, params);
  const queryString = getQueryString(path, params);
  for (const [key, value] of Object.entries(allParams))
    path = path.replace(new RegExp(`:${key}(/|$)`), value + "$1");
  return `${path}${queryString}`;
}
function getQueryString(path, params) {
  if (!runtime_config_default.queryHandler)
    return "";
  const ignoredKeys = pathToParamKeys(path);
  const queryParams = {};
  if (params)
    Object.entries(params).forEach(([key, value]) => {
      if (!ignoredKeys.includes(key))
        queryParams[key] = value;
    });
  return runtime_config_default.queryHandler.stringify(queryParams).replace(/\?$/, "");
}

// node_modules/@roxi/routify/runtime/plugins/tree.js
var setRegex = createNodeMiddleware(({ file }) => {
  if (file.isPage || file.isFallback)
    file.regex = pathToRegex(file.path, file.isFallback);
});
var setParamKeys = createNodeMiddleware(({ file }) => {
  file.paramKeys = pathToParamKeys(file.path);
});
var setShortPath = createNodeMiddleware(({ file }) => {
  if (file.isFallback || file.isIndex)
    file.shortPath = file.path.replace(/\/[^/]+$/, "");
  else
    file.shortPath = file.path;
});
var setRank = createNodeMiddleware(({ file }) => {
  file.ranking = pathToRank(file);
});
var addMetaChildren = createNodeMiddleware(({ file }) => {
  const node = file;
  const metaChildren = file.meta && file.meta.children || [];
  if (metaChildren.length) {
    node.children = node.children || [];
    node.children.push(...metaChildren.map((meta) => ({ isMeta: true, ...meta, meta })));
  }
});
var setIsIndexable = createNodeMiddleware((payload) => {
  const { file } = payload;
  const { isFallback, meta } = file;
  const isDynamic = file.path.split("/").pop().startsWith(":");
  const isIndex = file.path.endsWith("/index");
  const isIndexed = meta.index || meta.index === 0;
  const isHidden = meta.index === false;
  file.isIndexable = isIndexed || !isFallback && !isDynamic && !isIndex && !isHidden;
  file.isNonIndexable = !file.isIndexable;
});
var assignRelations = createNodeMiddleware(({ file, parent }) => {
  Object.defineProperty(file, "parent", { get: () => parent });
  Object.defineProperty(file, "nextSibling", { get: () => _getSibling(file, 1) });
  Object.defineProperty(file, "prevSibling", { get: () => _getSibling(file, -1) });
  Object.defineProperty(file, "lineage", { get: () => _getLineage(parent) });
});
function _getLineage(node, lineage = []) {
  if (node) {
    lineage.unshift(node);
    _getLineage(node.parent, lineage);
  }
  return lineage;
}
function _getSibling(file, direction) {
  if (!file.root) {
    const siblings = file.parent.children.filter((c) => c.isIndexable);
    const index = siblings.indexOf(file);
    return siblings[index + direction];
  }
}
var assignIndex = createNodeMiddleware(({ file, parent }) => {
  if (file.isIndex)
    Object.defineProperty(parent, "index", { get: () => file });
});
var assignLayout = createNodeMiddleware(({ file, scope }) => {
  Object.defineProperty(file, "layouts", { get: () => getLayouts(file) });
  function getLayouts(file2) {
    if (!file2.isLayout && file2.meta.reset)
      return [];
    const { parent } = file2;
    const layout = parent && parent.component && parent;
    const isReset = layout && (layout.isReset || layout.meta.reset);
    const layouts = parent && !isReset && getLayouts(parent) || [];
    if (layout)
      layouts.push(layout);
    return layouts;
  }
});
var createFlatList = (treePayload) => {
  createNodeMiddleware((payload) => {
    if (payload.file.isPage || payload.file.isFallback)
      payload.state.treePayload.routes.push(payload.file);
  }).sync(treePayload);
  treePayload.routes.sort((c, p) => c.ranking >= p.ranking ? -1 : 1);
};
var setPrototype = createNodeMiddleware(({ file }) => {
  const Prototype = file.root ? Root : file.children ? file.isPage ? PageDir : Dir : file.isReset ? Reset : file.isLayout ? Layout : file.isFallback ? Fallback : Page;
  Object.setPrototypeOf(file, Prototype.prototype);
  function Layout() {
  }
  function Dir() {
  }
  function Fallback() {
  }
  function Page() {
  }
  function PageDir() {
  }
  function Reset() {
  }
  function Root() {
  }
});

// node_modules/@roxi/routify/runtime/utils/normalizeNode.js
var defaultNode = {
  "isDir": false,
  "ext": "svelte",
  "isLayout": false,
  "isReset": false,
  "isIndex": false,
  "isFallback": false,
  "isPage": false,
  "ownMeta": {},
  "meta": {
    "recursive": true,
    "preload": false,
    "prerender": true
  },
  "id": "__fallback"
};
function restoreDefaults(node) {
  Object.entries(defaultNode).forEach(([key, value]) => {
    if (typeof node[key] === "undefined")
      node[key] = value;
  });
  if (node.children)
    node.children = node.children.map(restoreDefaults);
  return node;
}

// node_modules/@roxi/routify/runtime/plugins/assignAPI.js
var assignAPI = createNodeMiddleware(({ file }) => {
  file.api = new ClientApi(file);
});
var ClientApi = class {
  constructor(file) {
    this.__file = file;
    Object.defineProperty(this, "__file", { enumerable: false });
    this.isMeta = !!file.isMeta;
    this.path = file.path;
    this.title = _prettyName(file);
    this.meta = file.meta;
  }
  get parent() {
    return !this.__file.root && this.__file.parent.api;
  }
  get children() {
    return (this.__file.children || this.__file.isLayout && this.__file.parent.children || []).filter((c) => !c.isNonIndexable).sort((a, b) => {
      if (a.isMeta && b.isMeta)
        return 0;
      a = (a.meta.index || a.meta.title || a.path).toString();
      b = (b.meta.index || b.meta.title || b.path).toString();
      return a.localeCompare(b, void 0, { numeric: true, sensitivity: "base" });
    }).map(({ api }) => api);
  }
  get next() {
    return _navigate(this, 1);
  }
  get prev() {
    return _navigate(this, -1);
  }
  async preload() {
    const filePromises = [
      ...this.__file.layouts,
      this.__file,
      this.index && this.index.__file
      //if this is a layout, we want to include its index
    ].filter(Boolean).map((file) => file.component());
    await Promise.all(filePromises);
  }
  get component() {
    return this.__file.component ? (
      //is file?
      this.__file.component()
    ) : this.__file.index ? (
      //is dir with index?
      this.__file.index.component()
    ) : false;
  }
  get componentWithIndex() {
    return new Promise(
      (resolve) => Promise.all([
        this.component,
        this.index && this.index.component
      ]).then((res) => resolve(res))
    );
  }
  get index() {
    const child = this.__file.children && this.__file.children.find((child2) => child2.isIndex);
    return child && child.api;
  }
};
function _navigate(node, direction) {
  if (!node.__file.root) {
    const siblings = node.parent.children;
    const index = siblings.indexOf(node);
    return node.parent.children[index + direction];
  }
}
function _prettyName(file) {
  if (typeof file.meta.title !== "undefined")
    return file.meta.title;
  else
    return (file.shortPath || file.path).split("/").pop().replace(/-/g, " ");
}

// node_modules/@roxi/routify/runtime/buildRoutes.js
var plugins = {
  ...tree_exports,
  restoreDefaults: ({ tree }) => restoreDefaults(tree),
  assignAPI
};
function buildClientTree(tree) {
  const order = [
    // all
    "restoreDefaults",
    // pages
    "setParamKeys",
    //pages only
    "setRegex",
    //pages only
    "setShortPath",
    //pages only
    "setRank",
    //pages only
    "assignLayout",
    //pages only,
    // all
    "setPrototype",
    "addMetaChildren",
    "assignRelations",
    //all (except meta components?)
    "setIsIndexable",
    //all
    "assignIndex",
    //all
    "assignAPI",
    //all
    // routes
    "createFlatList"
  ];
  const payload = { tree, routes: [] };
  for (let name of order) {
    const fn = plugins[name].sync || plugins[name];
    fn(payload);
  }
  return payload;
}

export {
  runtime_config_default,
  handleScroll,
  suppressComponentWarnings,
  currentLocation,
  parseUrl,
  resolveUrl,
  buildClientTree
};
//# sourceMappingURL=chunk-AZ63GT6U.js.map
